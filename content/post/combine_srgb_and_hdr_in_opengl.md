---
title: "Combine_srgb_and_hdr_in_opengl"
date: 2024-02-29T14:32:33Z
draft: true
summary: "在OpenGL中结合sRGB和HDR"
---

# sRGB
首先需要明确概念：
sRGB是色彩空间映射，因为人眼对光照和色彩的感知并不是线性的（但是对于计算机中的计算，我们通常希望色彩空间是线性的）
所以有了sRGB色彩空间这种东西，实际上是一种非线性的色彩映射
一个与sRGB相关的概念是Gamma，我们通常将sRGB色彩空间定义为经过Gamma=2.2矫正的线性空间。通常·，在OpenGL中绘图时，我们需要在自己的管线中手动进行sRGB映射和Gamma矫正。因为绝大部分漫反射贴图在制作过程中，制作者就是按照sRGB色彩空间（他们的屏幕所显示的色彩）来进行的上色。所以这些漫反射贴图通常已经经过了一次sRGB映射。但是我们的程序需要的是线性空间内的色彩参数，所以需要进行转换。使用GL_SRGB或者GL_SRGB8_ALPHA8可以自动完成sRGB到线性空间的转化，或者你可以在GLSL中手动进行这一过程。 

需要注意的是，并不是所有的贴图都需要从SRGB转到线性空间。比如normal texture，他们所储存的就是法线数据（只不过以图形形式组织），而不是sRGB色彩空间下的图像数据。此时再对其进行从sRGB到线性空间的转换，就会破坏我们需要的法线数据

# HDR
还是先来明确概念，HDR是高动态范围，用于解决渲染管线的计算过程中可能出现的某一像素的RGB值短暂超过1.0的情况。如果没有HDR，当像素的某一RGB分量超过1.0，GLSL将会强制对其进行归一化，造成色彩偏差。

使用HDR（比如GL_RGBA16）后，其中像素的任意分量可以被保存为大于1.0的值，从而避免失真。

然而，HDR在绝大部分情况下都只应当应用在FBO上，而不是从外部加载的贴图。因为我们通常不会修改后者，绝大部分绘制和相关的片元着色计算都是发生在FBO上的。

值得一提的是，我们的屏幕（以及默认FBO）永远都是LDR（低动态范围），至少相对于渲染过程中可能出现的峰值RGB而言。所以，在将HDR FBO最终绘制到屏幕前，需要进行一次HDR转LDR的色彩映射。这一步很重要，直接关系到色彩风格，以及画面质感。

# 结合sRGB和HDR
理清楚概念后，答案显而易见：对从外部载入的漫反射纹理使用GL_SRGB8_ALPHA8，对FBO使用GL_RGBA16，然后在最终绘制到屏幕时，在GLSL中手动进行HDR转LDR色彩映射以及gamma矫正（以将线性空间转化为sRGB空间）。